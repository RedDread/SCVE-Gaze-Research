package uk.ac.salford.cvefm.model 
{
	import fl.controls.NumericStepper;
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.geom.Point;
	import uk.ac.salford.cvefm.controller.PokerDataController;
		
	/**
	 * ...
	 * @author Claire Miller
	 */
	public class BankData extends EventDispatcher
	{
		public static const POT_CLAIMED:String = "BankData_PotClaimed";
		public static const NO_MORE_BLINDS:String = "BankData_NoMoreBlinds";
		
		private var _currentBlindsIndex:Number;
		
		private var _largeBlind:Number;
		private var _smallBlind:Number;
		
		private var _nextLargeBlind:Number;
		private var _nextSmallBlind:Number;
		
		private var _incrementFlag:Boolean;
		
		private var _lastPlayerToRaiseId:Number;
		private var _lastRaise:Number;
		private var _lastBet:Number;
		private var _pot:Number;
		
		private var _split:Array;
		private var _splitCount:Number;
		
		private var _xml:XML;
		
		public function BankData (xml:XML) 
		{			
			_xml = xml;
			
			_nextSmallBlind = _smallBlind = _xml.blinds.blind[0].@small;
			_nextLargeBlind = _largeBlind = _xml.blinds.blind[0].@large;
			
			_currentBlindsIndex = 0;
			_splitCount = 0;
			_lastBet = 0;
			_lastRaise = 0;
			_pot = 0;
			
			_split = new Array ();
			_incrementFlag = false;
			
		}
		
		public function get blindInterval () :Number { return _xml.blinds[0].@time; }
		public function get blindsPos () :Point { return new Point (_xml.blinds[0].@x, _xml.blinds[0].@y) }
		public function get blindsRot () :Number { return _xml.blinds[0].@rotation }
		
		public function get smallBlind () :Number { return _smallBlind; }
		public function get largeBlind () :Number { return _largeBlind; }
		
		public function get nextSmallBlind () :Number { return _nextSmallBlind; }
		public function get nextLargeBlind () :Number { return _nextLargeBlind; }
		
		public function get lastPlayerToRaiseId () :Number { return _lastPlayerToRaiseId; }
		
		public function getLastRaise () :Number { return _lastRaise; }
		public function lastRaise (raise:Number, playerId:Number) :void 
		{
			if (raise > _lastRaise)
			{
				_lastRaise = raise; 
				_lastPlayerToRaiseId = playerId;
			}
		}
		
		public function get lastBet () :Number { return _lastBet; }
		public function set lastBet (bet:Number) :void { _lastBet = bet; }
		
		public function get pot () :Number { return _pot; }
		public function addToPot (bet:Number) :void { _pot += bet; }
		
		public function claimPot () :Number 
		{		
			var temp:Number = _pot;
			_pot = 0;
			return temp;
		}
		
		// 
		public function nextGame () :void
		{
			// Clean up the split pot if it exists
			_split.splice();
			_split = new Array();
			_splitCount = 0;
			
			// Increment the blinds if the clock went up while we were playing
			if (_incrementFlag)
			{
				_smallBlind = _nextSmallBlind;
				_largeBlind = _nextLargeBlind;
				_incrementFlag = false;
			}
			
			this.dispatchEvent(new Event (POT_CLAIMED));	
		}
		
		public function nextRound (playerId:Number) :void
		{
			_lastPlayerToRaiseId = playerId;
			_lastRaise = 0;
			_lastBet = 0;
		}
				
		public function incrementBlinds () :void
		{
			trace ("BankData::incrementBlinds");
			_currentBlindsIndex++;
			
			var blindsCount:Number = _xml.blinds.blind.length();
			if (_currentBlindsIndex >= blindsCount)
			{
				this.dispatchEvent(new Event (NO_MORE_BLINDS));	
				return;
			}
			
			_nextSmallBlind = _xml.blinds.blind[_currentBlindsIndex].@small;
			_nextLargeBlind = _xml.blinds.blind[_currentBlindsIndex].@large;
			
			_incrementFlag = true;
			
			//trace ("BankData::nextRound _currentBlindsIndex:" + _currentBlindsIndex);
			//trace ("BankData::nextRound _smallBlind:" + _smallBlind);
			//trace ("BankData::nextRound _largeBlind:" + _largeBlind);
		}
		
		public function isSplitPot () :Boolean
		{
			if (_split.length > 1)
			{
				return true;
			}
			return false;
		}
		
		public function setSplit (bet:Number, playerId:Number) :void
		{
			var split:PlayerSplitDataVo = new PlayerSplitDataVo (playerId, bet);
			_split.push(split);
		}
		
		
		public function getSplit (playerId:Number) :Number
		{
			if (_splitCount == 0)
			{
				calculateTheSplit (playerId);
			}
			_splitCount++;
			
			return getSplitById (playerId);
		}
		
		private function calculateTheSplit (playerId:Number) :void
		{
			// Sort from largest to smallest - 0 index is largest bet.
			trace ("BankData::calculateTheSplit before" + _split);
			_split.sortOn ("bet", Array.DESCENDING);
			trace ("BankData::calculateTheSplit after" + _split);
			
			if (_split.length > 2)
			{
				// Make the two highest bets the same, the highest claiming any overspend
				PlayerSplitDataVo(_split[0]).claim = PlayerSplitDataVo(_split[0]).bet - PlayerSplitDataVo(_split[1]).bet;
				PlayerSplitDataVo(_split[0]).bet = PlayerSplitDataVo(_split[1]).bet; 
				
				if (getPlayerIndex (playerId)  == 2) 
				{
					// Smallest is claiming first, split the leftovers
					PlayerSplitDataVo(_split[2]).claim = PlayerSplitDataVo(_split[2]).bet * 3; 
					PlayerSplitDataVo(_split[1]).claim += PlayerSplitDataVo(_split[1]).bet - PlayerSplitDataVo(_split[2]).bet;
					PlayerSplitDataVo(_split[0]).claim += PlayerSplitDataVo(_split[0]).bet - PlayerSplitDataVo(_split[2]).bet;
				}
				else
				{
					// Otherwise the biggest of the other two claims it all
					PlayerSplitDataVo(_split[getPlayerIndex (playerId)]).claim += (PlayerSplitDataVo(_split[getPlayerIndex (playerId)]).bet * 2) + PlayerSplitDataVo(_split[2]).bet;
				}
			}
			else
			{
				// Two player split
				if (getPlayerIndex (playerId) == 0)
				{
					// Largest wins all
					PlayerSplitDataVo(_split[0]).claim += PlayerSplitDataVo(_split[0]).bet + PlayerSplitDataVo(_split[1]).bet;				
				}
				else
				{
					// Smallest takes away twice their winnings and the largest gets that taken from their claim
					PlayerSplitDataVo(_split[1]).claim += PlayerSplitDataVo(_split[1]).bet * 2;
					PlayerSplitDataVo(_split[0]).claim += PlayerSplitDataVo(_split[0]).bet - PlayerSplitDataVo(_split[1]).bet;
				}
			}
			trace ("BankData::calculateTheSplit after" + _split);
		}
		
		private function getSplitById (playerId:Number) :Number
		{
			return PlayerSplitDataVo(_split[getPlayerIndex(playerId)]).claim;
		}
		
		private function getPlayerIndex (playerIndex:Number) :Number
		{
			for (var i:int = 0; i < _split.length; i++) 
			{
				if (PlayerSplitDataVo(_split[i]).playerId == playerIndex)
				{
					return i;
				}
			}
			
			return -1;
		}
		
		
	}

}