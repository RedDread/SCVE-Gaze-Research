package uk.ac.salford.cvefm.model 
{
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import uk.ac.salford.cvefm.controller.PokerDataController;
	/**
	 * ...
	 * @author Claire Miller
	 */
	public class PlayerData extends EventDispatcher
	{
		//public static const BET_CHANGED:String = "PlayerData_BetChanged"
		public static const BANK:String = "PlayerData_Bank"
		
		public static const FOLD:String = "Fold"
		public static const ALL_IN:String = "All_In"
		public static const CHECK_BET:String = "Check_Bet"
		public static const RAISE:String = "Raise"
		
		private var _cardX:Number;
		private var _cardY:Number;
		private var _cardRotation:Number;
		
		private var _panelX:Number;
		private var _panelY:Number;
		private var _panelRotation:Number;
		
		private var _playerTotal:Number;
		private var _currentBet:Number;	
		private var _currentRaise:Number;
		
		private var _isActive:Boolean;
		private var _isAllIn:Boolean;
		private var _hasPlayed:Boolean;
		private var _isOut:Boolean;
		
		private var _bankData:BankData;
		
		private var _playerId:Number;

		
		public function PlayerData (xml:XML, playerId:Number)
		{
			_playerId = playerId;
			
			_cardX = xml.card.@x;
			_cardY = xml.card.@y;
			_cardRotation = xml.card.@rotation;
			
			_panelX = xml.panel.@x;
			_panelY = xml.panel.@y;
			_panelRotation = xml.panel.@rotation;
			
			_playerTotal = xml.@starting_pot;
			
			_isActive = true;
			_isAllIn = false;
			_hasPlayed = false;
			_isOut = false;
			
			_currentBet = _currentRaise = 0;
			_bankData = PokerDataController.getInstance ().getBankData();
		}
		
		public function get playerId():Number { return _playerId; }
		public function get isActive():Boolean { return _isActive; }
		public function get isAllIn():Boolean { return _isAllIn; }
		public function get hasPlayed():Boolean { return _hasPlayed; }
		public function get isOut():Boolean { return _isOut; }
		
		public function get cardX():Number { return _cardX; }
		public function get cardY():Number { return _cardY; }
		public function get cardRotation():Number { return _cardRotation; }
		
		public function get panelX():Number { return _panelX; }
		public function get panelY():Number { return _panelY; }
		public function get panelRotation():Number { return _panelRotation; }
		
		public function get playerTotal():Number { return _playerTotal; }
		public function get currentRaise():Number { return _currentRaise; }
		public function set currentRaise(raiseValue:Number) :void { _currentRaise = raiseValue; }
		public function get currentBet():Number 
		{
			return _currentBet; 
		}
		
		public function matchedBet () :Boolean
		{
			if (_currentBet >= _bankData.lastBet && _hasPlayed)
			{
				return true;
			}
			return false;
		}
		
		public function set currentBet(betValue:Number) :void 
		{
			_currentBet = betValue; 
			trace ("PlayerData::currentBet " + _currentBet + " playerId:" + _playerId);
		}
		
		public function claimPot () :void
		{
			if (_bankData.isSplitPot ())
			{
				_playerTotal += _bankData.getSplit (_playerId);
				_bankData.claimPot (); // Claim it to clear it
			}
			else
			{
				_playerTotal += _bankData.claimPot();
			}
			var temp:Number = _playerTotal;
			_bankData.nextGame ();
		}
		
		/**
		 * Bank the players cash at the end of the round
		 * @return
		 */
		public function bank () :void
		{
			trace ("PlayerData::bank bet:" + _currentBet + " _playerTotal (after bet):" + _playerTotal + " playerId:" +_playerId );
			
			_playerTotal -= _currentBet;
			_bankData.addToPot (_currentBet);
			
			_currentBet = 0;
			_currentRaise = 0;
			
			dispatchEvent (new Event (BANK, false));
			
			_hasPlayed = false;
		}
		
		public function nextGame () :void
		{
			trace ("PlayerData::nextGame - resetting raises and blinds");
			
			_currentBet = 0;
			_currentRaise = 0;
			_isAllIn = false;
			_hasPlayed = false;
			
			if (_playerTotal > 0)
			{
				_isActive = true;
			}
			else
			{
				_isOut = true;
			}
			
		}
		
		//7. The Minimum bet/raise is equal to the BB. Any re-raise must be equal or greater than the previous raise.
		public function bet () :void
		{
			// Raise is virtual, once you raise it's added to your bet, flag only
			if (_currentRaise < _bankData.getLastRaise())
			{
				_currentRaise = (_bankData.getLastRaise () * 2);
			}
			
			_currentBet += _currentRaise;
			
			// If the bet is 0, set the bet and raise to large  blind
			if (_currentBet == 0)
			{
				_currentBet = _bankData.largeBlind;
				_currentRaise = _currentBet;
			}
			
			if (_currentBet == _playerTotal)
			{
				_bankData.setSplit (_currentBet, playerId);
				_isAllIn = true;
			}
			
			_bankData.lastBet = _currentBet;
			_bankData.lastRaise (_currentRaise, _playerId);
			
			_hasPlayed = true;
		}
		
		public function callCheck () :void
		{	
			// Make sure current bet me
			_currentBet = _bankData.lastBet;
			
			if (_currentBet > _bankData.getLastRaise ())
			{
				_bankData.lastRaise (_currentBet, _playerId);
			}
			
			// Check that we have enough to call
			if (_currentBet >= _playerTotal)
			{
				_currentBet = _playerTotal;

				_isAllIn = true;
				_bankData.setSplit (_currentBet, playerId);
			}
			
			// Last bet hasn't changed so we don't have to update
			_hasPlayed = true;
		}
		
		public function allIn () :void
		{
			_currentBet = _playerTotal;
			
			// If the player total is less than the last bet, the last bet stands
			if (_currentBet > _bankData.lastBet)
			{
				_bankData.lastRaise ((_currentBet -_bankData.lastBet), _playerId);
			}
			
			_bankData.lastBet = _currentBet;
			_bankData.setSplit (_currentBet, playerId);
			
			_isAllIn = true;
			_hasPlayed = true;
		}
		
		public function fold () :void
		{
			_isActive = false;
			_hasPlayed = true;
		}
		
	
		/**
		 * These change the raise values
		 */
		
		public function increaseRaise () :void
		{
			// Only allow increase to player total
			if (_currentRaise + _currentBet +  _bankData.getLastRaise() < _playerTotal)
			{
				if (_bankData.getLastRaise() > 0)
				{
					_currentRaise += _bankData.getLastRaise();
				}
				else
				{
					_currentRaise += _bankData.largeBlind;
				}
				
				trace ("PlayerData::increaseRaise " + _currentRaise + " bank last raise: " + _bankData.getLastRaise ());
			}
		}
		
		public function decreaseRaise () :void
		{
			if (_bankData.getLastRaise() > 0)
			{
				_currentRaise -= _bankData.getLastRaise();
			}
			else
			{
				_currentRaise -= _bankData.largeBlind;
			}
			
			// Only allow to decrease to the last raise
			if (_currentRaise < _bankData.getLastRaise())
			{
				_currentRaise == _bankData.getLastRaise();
			}
			
			if (_currentRaise < 0)
			{
				_currentRaise = 0;
			}
		}
		
	}

}