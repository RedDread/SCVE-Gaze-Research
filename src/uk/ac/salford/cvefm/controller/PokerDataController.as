package uk.ac.salford.cvefm.controller 
{
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.geom.Point;
	import flash.net.URLLoader;
	import flash.net.URLRequest;
	import uk.ac.salford.cvefm.model.BankData;
	import uk.ac.salford.cvefm.model.CardData;
	import uk.ac.salford.cvefm.model.PlayerData;
	
	/**
	 * Singleton Class
	 * @author Claire Miller
	 */
	public class PokerDataController extends EventDispatcher
	{
		public static const NEXT_ROUND:String = "PokerDataController_NextRound";
		public static const GAME_END:String = "PokerDataController_End";
		public static const LOADED:String = "PokerDataController_Loaded";
		public static const NO_MORE_ACTIVE_PLAYERS:String = "PokerDataController_NoMoreActivePlayers";
		
		
		public static const BLINDS:String = "Blinds";
		public static const PRE_FLOP:String = "Pre-Flop";
		public static const FLOP:String = "Flop";
		public static const TURN:String = "Turn";
		public static const RIVER:String = "River";
		
		public static const GAME_STATES:Array = new Array (/*BLINDS, */PRE_FLOP, FLOP, TURN, RIVER);
		public static const NUM_PLAYERS:Number = 3;
		
		private static var _instance:PokerDataController;
		private static var _allowInstantation:Boolean;		
		
		private var _cardData:CardData;
		private var _bankData:BankData;
		
		private var _currentBettingRound:Number;  // CurrentBettingRound
		private var _currentPlayer:Number;
		private var _dealerIndex:Number;
		private var _lastLargeBlindPlayerIndex:Number;
		
		private var _playersData:Array;		
		private var _communityCardsPos:Point;
		private var _potPos:Point;
		private var _xmlLoader:URLLoader;
		private var _isCurrentGameEnded:Boolean;
		/**
		* Get singleton instance of this class
		* @return this!!
		*/
		public static function getInstance () :PokerDataController
		{
			if (_instance == null)
			{
				_allowInstantation = true;
				_instance = new PokerDataController ();
			}
			
			return _instance;
		}
		
		/**
		* Data Manager constructor
		*/		
		public function PokerDataController ()
		{
			if (!_allowInstantation) 
			{
				throw new Error ("Error: Instantiation failed: Use PokerDataController.getInstance() instead of new.");
			}
			
			//MonsterDebugger.trace (this, "PokerDataController::PokerDataController ", BuildEnvironment.DEBUG_COLOUR_DATA);
			
			_allowInstantation = false;
			_isCurrentGameEnded = false;
			
			_xmlLoader = new URLLoader();
			_xmlLoader.addEventListener (Event.COMPLETE, onConfigLoaded);
			_xmlLoader.load (new URLRequest("config.xml"));
		}

		private function onConfigLoaded (event:Event):void 
		{
			XML.ignoreWhitespace = true; 
			var xml:XML = new XML (event.target.data);
			
			_bankData = new BankData (xml.bank[0]);
			_bankData.addEventListener (BankData.POT_CLAIMED, onNextGame, false, 0, true);
			
			_cardData = new CardData ();			
			_cardData.addEventListener (CardData.LOADED, onCardDataLoaded, false, 0, true);
			
			//Refactor if you fancy it
			var playerOne:PlayerData = new PlayerData (xml.player[0],0);
			var playerTwo:PlayerData = new PlayerData (xml.player[1],1);
			var playerThree:PlayerData = new PlayerData (xml.player[2],2);
			
			_communityCardsPos = new Point (xml.community.@x, xml.community.@y);
			_potPos = new Point (xml.pot.@x, xml.pot.@y);
			
			_playersData = new Array (playerOne, playerTwo, playerThree);
			
			_currentBettingRound = 0;
			
			// CMTODO - renable for random start
			_currentPlayer = _dealerIndex = Math.floor (3 * Math.random ());
			//_currentPlayer = _dealerIndex = 0;
			
			setBlinds ();
		}		
		
		private function onCardDataLoaded (event:Event) :void
		{
			dispatchEvent (new Event (LOADED, false));
		}
		
		public function get isCurrentGameEnded () :Boolean
		{
			return _isCurrentGameEnded;
		}
		
		public function get currentRound () :Number
		{
			return _currentBettingRound;
		}
		
		public function get currentPlayer () :Number
		{
			return _currentPlayer;
		}
		
		public function get currentDealer () :Number
		{
			return _dealerIndex;
		}
		
		public function moveToNextPlayer () :void
		{
			var count:Number;
			var active:Number;
			
			if (allPlayersFinished())
			{
				checkRoundOrEnd ();
				return;
			}
			
			_currentPlayer = getNextActivePlayer (_currentPlayer);
			
			// Check if all players have called the raise
			// by checking if next player was the last person to play the highest raise			
			trace ("PokerDataController::moveToNextPlayer last player to raise:" + _bankData.lastPlayerToRaiseId + " current player:" + _currentPlayer);
			
			if (_bankData.lastPlayerToRaiseId == _currentPlayer)
			{
				checkRoundOrEnd ();
			}
		}
		
		private function checkRoundOrEnd () :void
		{
			_currentBettingRound++;

			if (_currentBettingRound >= GAME_STATES.length)
			{
				endCurrentGame ();
			}
			else
			{
				setNextRound ();
			}
		}
		
		private function allPlayersFinished () :Boolean
		{
			var inactiveCount:Number = 0;
			for (var index:int = 0; index < NUM_PLAYERS; index++) 
			{
				trace ("PokerDataController::allPlayersFinished isActive:" + !PlayerData(_playersData[index]).isActive + " isAllin:" + PlayerData(_playersData[index]).isAllIn + " matched:" + PlayerData (_playersData[index]).matchedBet());
				if (!PlayerData(_playersData[index]).isActive 
					|| PlayerData(_playersData[index]).isAllIn 
					|| PlayerData (_playersData[index]).matchedBet() 
					|| PlayerData (_playersData[index]).isOut)
				{
					inactiveCount++;
				}
			}
			
			trace ("PokerDataController::allPlayerBet allPlayersFinished:" + inactiveCount);
			
			if (inactiveCount == NUM_PLAYERS)
			{
				return true;
			}
			
			return false;
		}
		
		private function setNextRound () :void
		{
			// Bank - set each players chips to the bank, which will reset them for the next round
			for (var index:int = 0; index < _playersData.length; index++) 
			{
				PlayerData(_playersData[index]).bank ();
			}
			
			if (allPlayersFinished())
			{
				endCurrentGame();
			}
			else
			{
				// Set the current player to one after the dealer
				_currentPlayer = getNextActivePlayer (_dealerIndex);
				
				// Reset the bank with last player to raise id
				_bankData.nextRound (_currentPlayer);
			
				dispatchEvent (new Event (NEXT_ROUND, false));
			}
		}
		
		private function endCurrentGame () :void
		{
			_isCurrentGameEnded = true;
			dispatchEvent (new Event (GAME_END, false));
		}
		
		public function getBankData () :BankData
		{
			return _bankData;
		}
		
		public function getCardData () :CardData
		{
			return _cardData;
		}
		
		public function getPlayerData (index:Number) :PlayerData
		{
			return _playersData[index];
		}
		
		public function get communityCardsPoint ():Point 
		{ 
			return _communityCardsPos; 
		}
		
		public function get potPoint ():Point 
		{ 
			return _potPos; 
		}
		
		private function setBlinds () :void
		{
			trace ("PokerDataController::setBlinds");
			
			// This would be more complicated in a full game but just handling scenarios for 3 and 2 players
			if (_playersData.length > 3)
			{
				throw new Error ("More players than I've planned for");
			}
			
			var temp:Number = 0;
			
			switch (numberActivePlayers())
			{
				case 3:
				{
					// Three Players
					temp = _dealerIndex % 3;
					PlayerData(_playersData [temp]).currentBet = 0;
					_currentPlayer = temp;
					
					temp = (_dealerIndex + 1) % 3;
					PlayerData(_playersData [temp]).currentBet = _bankData.smallBlind;
					
					temp = (_dealerIndex + 2) % 3;
					PlayerData(_playersData [temp]).currentBet = _bankData.largeBlind;
					_lastLargeBlindPlayerIndex = temp;
					
					//_bankData.lastRaise(_bankData.largeBlind, temp);
					_bankData.lastBet = _bankData.largeBlind;
					
					_currentPlayer = _dealerIndex;
					break;
				}
				case 2:
				{				
					var nextLarge:Number = getNextActivePlayer (_lastLargeBlindPlayerIndex);
					PlayerData(_playersData [nextLarge]).currentBet = _bankData.largeBlind;
					
					_lastLargeBlindPlayerIndex = nextLarge;
					
					var small:Number = getNextActivePlayer (_lastLargeBlindPlayerIndex);
					PlayerData(_playersData [small]).currentBet = _bankData.smallBlind;				
					
					//_bankData.lastRaise(_bankData.largeBlind, nextLarge);
					_bankData.lastBet = _bankData.largeBlind;
					break;
				}
				case 1:
				{
					// No more players
					this.dispatchEvent (new Event (NO_MORE_ACTIVE_PLAYERS));	
					break;
				}
			}
		}
		
		private function onNextGame (event:Event) :void
		{
			// Reset player data for next game
			for (var index:Number = 0; index < PokerDataController.NUM_PLAYERS; index++) 
			{
				_playersData[index].nextGame ();
			}
			
			_dealerIndex = getNextActivePlayer (_dealerIndex);
			
			// Reset the cards, pot and etc
			_currentBettingRound = 0;
			_isCurrentGameEnded = false;
			
			// Reset the bet and raise
			_bankData.nextRound (_dealerIndex);
			
			setBlinds ();
		}
		
		public function getNextActivePlayer (index:Number) :Number
		{
			var activePlayerCount:Number = 0;
			var nextActivePlayer:Number = index;
			
			do
			{
				nextActivePlayer++;
				nextActivePlayer = nextActivePlayer % NUM_PLAYERS;
				activePlayerCount++;
				
				if (activePlayerCount > NUM_PLAYERS)
				{
					this.dispatchEvent (new Event (NO_MORE_ACTIVE_PLAYERS));
				}
			} while (!PlayerData(_playersData[nextActivePlayer]).isActive  
				|| PlayerData(_playersData[nextActivePlayer]).isAllIn
				|| PlayerData(_playersData[nextActivePlayer]).isOut)
			
			return nextActivePlayer;
		}
		
		private function numberActivePlayers () :Number
		{
			var activePlayerCount:Number = 0;
			for (var i:int = 0; i < NUM_PLAYERS; i++) 
			{
				if (PlayerData(_playersData[i]).isActive  
				&& !PlayerData(_playersData[i]).isOut)
				{
					activePlayerCount++;
				}
			}
			trace ("PokerDataController::numberActivePlayers " + activePlayerCount);
			return activePlayerCount;
		}
	}

}