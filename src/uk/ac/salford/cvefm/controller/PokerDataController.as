package uk.ac.salford.cvefm.controller 
{
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.geom.Point;
	import flash.net.URLLoader;
	import flash.net.URLRequest;
	import uk.ac.salford.cvefm.model.BankData;
	import uk.ac.salford.cvefm.model.CardData;
	import uk.ac.salford.cvefm.model.PlayerData;
	
	/**
	 * Singleton Class
	 * @author Claire Miller
	 */
	public class PokerDataController extends EventDispatcher
	{
		public static const NEXT_ROUND:String = "PokerDataController_NextRound";
		public static const GAME_END:String = "PokerDataController_End";
		public static const LOADED:String = "PokerDataController_Loaded";
		
		public static const BLINDS:String = "Blinds";
		public static const PRE_FLOP:String = "Pre-Flop";
		public static const FLOP:String = "Flop";
		public static const TURN:String = "Turn";
		public static const RIVER:String = "River";
		
		public static const GAME_STATES:Array = new Array (BLINDS, PRE_FLOP, FLOP, TURN, RIVER);
		public static const NUM_PLAYERS:Number = 3;
		
		private static var _instance:PokerDataController;
		private static var _allowInstantation:Boolean;		
		
		private var _cardData:CardData;
		private var _bankData:BankData;
		
		private var _currentBettingRound:Number;  // CurrentBettingRound
		private var _currentPlayer:Number;
		private var _dealerIndex:Number;
		
		private var _players:Array;		
		private var _communityCardsPos:Point;
		private var _potPos:Point;
		private var _xmlLoader:URLLoader;
		private var _isCurrentGameEnded:Boolean;
		/**
		* Get singleton instance of this class
		* @return this!!
		*/
		public static function getInstance () :PokerDataController
		{
			if (_instance == null)
			{
				_allowInstantation = true;
				_instance = new PokerDataController ();
			}
			
			return _instance;
		}
		
		/**
		* Data Manager constructor
		*/		
		public function PokerDataController ()
		{
			if (!_allowInstantation) 
			{
				throw new Error ("Error: Instantiation failed: Use PokerDataController.getInstance() instead of new.");
			}
			
			//MonsterDebugger.trace (this, "PokerDataController::PokerDataController ", BuildEnvironment.DEBUG_COLOUR_DATA);
			
			_allowInstantation = false;
			_isCurrentGameEnded = false;
			
			_xmlLoader = new URLLoader();
			_xmlLoader.addEventListener (Event.COMPLETE, onConfigLoaded);
			_xmlLoader.load (new URLRequest("config.xml"));
		}

		private function onConfigLoaded (event:Event):void 
		{
			XML.ignoreWhitespace = true; 
			var xml:XML = new XML (event.target.data);
			
			_bankData = new BankData (xml.bank[0]);
			_bankData.addEventListener (BankData.POT_CLAIMED, onNextGame, false, 0, true);
			
			_cardData = new CardData ();			
			_cardData.addEventListener (CardData.LOADED, onCardDataLoaded, false, 0, true);
			
			//Refactor if you fancy it
			var playerOne:PlayerData = new PlayerData (xml.player[0],0);
			var playerTwo:PlayerData = new PlayerData (xml.player[1],1);
			var playerThree:PlayerData = new PlayerData (xml.player[2],2);
			
			_communityCardsPos = new Point (xml.community.@x, xml.community.@y);
			_potPos = new Point (xml.pot.@x, xml.pot.@y);
			
			_players = new Array (playerOne, playerTwo, playerThree);
			
			_currentBettingRound = 0;
			
			// CMTODO - renable for random start
			//_currentPlayer = _dealerIndex = Math.floor (3 * Math.random ());
			_currentPlayer = _dealerIndex = 0;
			
			setBlinds ();
		}		
		
		private function onCardDataLoaded (event:Event) :void
		{
			dispatchEvent (new Event (LOADED, false));
		}
		
		public function get isCurrentGameEnded () :Boolean
		{
			return _isCurrentGameEnded;
		}
		
		public function get currentRound () :Number
		{
			return _currentBettingRound;
		}
		
		public function get currentPlayer () :Number
		{
			return _currentPlayer;
		}
		
		public function get currentDealer () :Number
		{
			return _dealerIndex;
		}
		
		public function moveToNextPlayer () :void
		{
			var count:Number;
			var active:Number;
			
			for (var i:int = 0; i < NUM_PLAYERS; i++) 
			{
				if (PlayerData(_players[_currentPlayer]).isActive) active++;
			}
			
			if (active <= 1)
			{
				throw new Error ("End Round to be completed - pay last active player!");
			}
			else
			{			
				do 
				{
					_currentPlayer++;
					_currentPlayer = _currentPlayer % NUM_PLAYERS;
					count++
					
					if (count > NUM_PLAYERS)
					{
						endCurrentGame ();
						return;
					}
				}
				while (!PlayerData(_players[_currentPlayer]).isActive)
			}
			
			// Check if all players have called the raise
			// by checking if next player was the last person to play the highest raise
			if (_bankData.lastPlayerToRaiseId == _currentPlayer)
			{
				_currentBettingRound++;

				if (_currentBettingRound >= GAME_STATES.length)
				{
					endCurrentGame ();
				}
				else
				{
					// Get the chips and reset the raise
					for (var index:int = 0; index < _players.length; index++) 
					{
						PlayerData(_players[index]).bank ();
					}
					
					// Reset the bet and raise
					_bankData.lastBet = 0;
					_bankData.lastRaise (0, _currentPlayer);
					
					dispatchEvent (new Event (NEXT_ROUND, false));
				}
			}
		}
		
		private function endCurrentGame () :void
		{
			_isCurrentGameEnded = true;
			dispatchEvent (new Event (GAME_END, false));
		}
		
		public function getBankData () :BankData
		{
			return _bankData;
		}
		
		public function getCardData () :CardData
		{
			return _cardData;
		}
		
		public function getPlayerData (index:Number) :PlayerData
		{
			return _players[index];
		}
		
		public function get communityCardsPoint ():Point 
		{ 
			return _communityCardsPos; 
		}
		
		public function get potPoint ():Point 
		{ 
			return _potPos; 
		}
		
		private function setBlinds () :void
		{
			var temp:Number = 0;
			if (_players.length > 2)
			{
				temp = _dealerIndex % 3;
				PlayerData(_players [temp]).currentBet = 0;
				
				temp = (_dealerIndex + 1) % 3;
				PlayerData(_players [temp]).currentBet = _bankData.smallBlind;
				
				temp = (_dealerIndex + 2) % 3;
				PlayerData(_players [temp]).currentBet = _bankData.largeBlind;
				
				_bankData.lastRaise(_bankData.largeBlind, temp);
				_bankData.lastBet = _bankData.largeBlind;
			}
			else
			{
				throw new Error ("PokerDataController::setBlinds CMTODO Need to complete player removal and extended blinds logic");
			}
		}
		
		private function onNextGame (event:Event) :void
		{
			_dealerIndex++;
			_dealerIndex = _dealerIndex % NUM_PLAYERS;
			
			// Reset the cards, pot and etc
			_currentBettingRound = 0;
			_isCurrentGameEnded = false;
			
			// Reset the bet and raise
			//_bankData.lastBet = 0;
			//_bankData.lastRaise (0, _currentPlayer);
			
			// Move player data onto next game
			for (var index:Number = 0; index < PokerDataController.NUM_PLAYERS; index++) 
			{
				_players[index].nextGame ();
			}

			setBlinds ();
		}
	}

}