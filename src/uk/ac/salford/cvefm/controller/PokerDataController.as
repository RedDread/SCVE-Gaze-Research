package uk.ac.salford.cvefm.controller 
{
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.geom.Point;
	import flash.net.URLLoader;
	import flash.net.URLRequest;
	import uk.ac.salford.cvefm.model.BankData;
	import uk.ac.salford.cvefm.model.CardData;
	import uk.ac.salford.cvefm.model.PokerPlayerData;
	
	/**
	 * Singleton Class
	 * @author Claire Miller
	 */
	public class PokerDataController extends EventDispatcher
	{
		// For arguments sake: Each betting round is known as a ROUND, each complete game is a HAND, and the entire thing is the GAME
		public static const NEXT_HAND:String = "PokerDataController_NextHand";
		public static const LOADED:String = "PokerDataController_Loaded";
		public static const NO_MORE_ACTIVE_PLAYERS:String = "PokerDataController_NoMoreActivePlayers";
		
		
		public static const BLINDS:String = "Blinds";
		public static const PRE_FLOP:String = "Pre-Flop";
		public static const FLOP:String = "Flop";
		public static const TURN:String = "Turn";
		public static const RIVER:String = "River";
		public static const CLAIM:String = "Claim";
		public static const HAND_END:String = "End";
		
		public static const GAME_STATES:Array = new Array (BLINDS, PRE_FLOP, FLOP, TURN, RIVER, CLAIM);
		public static const NUM_PLAYERS:Number = 3;
		
		private static var _instance:PokerDataController;
		private static var _allowInstantation:Boolean;		
		
		private var _cardData:CardData;
		private var _bankData:BankData;
		
		private var _currentBettingRound:Number;  // CurrentBettingRound
		private var _currentPlayer:Number;
		private var _dealerIndex:Number;
		
		private var _lastLargeBlindPlayerIndex:Number;
		
		private var _playersData:Array;		
		private var _communityCardsPos:Point;
		private var _potPos:Point;
		private var _xmlLoader:URLLoader;
		private var _isClaiming:Boolean;

		/**
		* Get singleton instance of this class
		* @return this!!
		*/
		public static function getInstance () :PokerDataController
		{
			if (_instance == null)
			{
				_allowInstantation = true;
				_instance = new PokerDataController ();
			}
			
			return _instance;
		}
		
		/**
		* Data Manager constructor
		*/		
		public function PokerDataController ()
		{
			if (!_allowInstantation) 
			{
				throw new Error ("Error: Instantiation failed: Use PokerDataController.getInstance() instead of new.");
			}
			
			//MonsterDebugger.trace (this, "PokerDataController::PokerDataController ", BuildEnvironment.DEBUG_COLOUR_DATA);
			
			_allowInstantation = false;
			
			_xmlLoader = new URLLoader();
			_xmlLoader.addEventListener (Event.COMPLETE, onConfigLoaded);
			_xmlLoader.load (new URLRequest("config.xml"));
		}

		private function onConfigLoaded (event:Event):void 
		{
			XML.ignoreWhitespace = true; 
			var xml:XML = new XML (event.target.data);
			
			_bankData = new BankData (xml.bank[0]);
			//_bankData.addEventListener (BankData.POT_CLAIMED, onNextHand, false, 0, true);
			
			_cardData = new CardData ();			
			_cardData.addEventListener (CardData.LOADED, onCardDataLoaded, false, 0, true);
			
			//Refactor if you fancy it
			var playerOne:PokerPlayerData = new PokerPlayerData (xml.player[0],0);
			var playerTwo:PokerPlayerData = new PokerPlayerData (xml.player[1],1);
			var playerThree:PokerPlayerData = new PokerPlayerData (xml.player[2],2);
			
			_communityCardsPos = new Point (xml.community.@x, xml.community.@y);
			_potPos = new Point (xml.pot.@x, xml.pot.@y);
			
			_playersData = new Array (playerOne, playerTwo, playerThree);
			
			_currentBettingRound = 0;
			_isClaiming = false;
			
			// Randomise the first dealer
			_currentPlayer = _dealerIndex = Math.floor (3 * Math.random ());
			
			//setBlinds ();
		}		
		
		private function onCardDataLoaded (event:Event) :void
		{
			dispatchEvent (new Event (LOADED, false));
		}
		
		public function get currentRound () :Number
		{
			return _currentBettingRound;
		}
		
		public function get currentPlayer () :Number
		{
			return _currentPlayer;
		}
		
		public function get currentDealer () :Number
		{
			return _dealerIndex;
		}
		
		public function bankPlayerBets () :void
		{
			var index:int = 0;
			if (!_isClaiming)
			{
				for (index = 0; index < NUM_PLAYERS; index++) 
				{
					if (PokerPlayerData (_playersData[index]).isActive)
					{
						PokerPlayerData (_playersData[index]).bank ();
					}
				}
				_currentBettingRound++;
			}
			else
			{
				for (index = 0; index < NUM_PLAYERS; index++) 
				{
					if (PokerPlayerData (_playersData[index]).isActive)
					{
						PokerPlayerData (_playersData[index]).claim ();
					}
				}
				_currentBettingRound = 0;
			}
			
			trace ("PokerDataController::bankPlayerBets " + _currentBettingRound);
		}
		
		public function setClaim () :void
		{
			_isClaiming = true;
		}
		
		public function getBankData () :BankData
		{
			return _bankData;
		}
		
		public function getCardData () :CardData
		{
			return _cardData;
		}
		
		public function getPokerPlayerData (index:Number) :PokerPlayerData
		{
			return _playersData[index];
		}
		
		public function get communityCardsPoint ():Point 
		{ 
			return _communityCardsPos; 
		}
		
		public function get potPoint ():Point 
		{ 
			return _potPos; 
		}
			
		public function nextPlayer () :void
		{
			_currentPlayer = getNextActivePlayer (_currentPlayer);
		}
		
		public function previousPlayer () :void
		{
			_currentPlayer = getPreviousActivePlayer (_currentPlayer);
		}
		
		private function nextHand () :void
		{
			_dealerIndex = getNextActivePlayer (_dealerIndex);
			_isClaiming = false;
			
			trace ("PokerDataController::onNextHand dealer: " + _dealerIndex);
			
			// Reset the cards, pot and etc
			_currentBettingRound = 0;
			
			// Reset the bet and raise
			_bankData.nextRound (_dealerIndex);
			
			//setBlinds ();
		}
		
		private function getNextActivePlayer (index:Number) :Number
		{
			var activePlayerCount:Number = 0;
			var nextActivePlayer:Number = index;
			
			do
			{
				// Get the next player
				nextActivePlayer++;
				
				// Check the index is in bounds
				nextActivePlayer = nextActivePlayer % NUM_PLAYERS;
				activePlayerCount++;
				
				if (activePlayerCount > NUM_PLAYERS)
				{
					this.dispatchEvent (new Event (NO_MORE_ACTIVE_PLAYERS));
					break;
				}
				
				trace ("PokerDataController::getNextActivePlayer active: " + PokerPlayerData(_playersData[nextActivePlayer]).isActive);
			} while (!PokerPlayerData(_playersData[nextActivePlayer]).isActive);
			
			return nextActivePlayer;
		}
		
		private function getPreviousActivePlayer (index:Number) :Number
		{
			var activePlayerCount:Number = 0;
			var previousActivePlayer:Number = index;
			
			do
			{
				// Get the next player
				previousActivePlayer--;
				
				// Check the index is in bounds
				if (previousActivePlayer < 0)
				{
					previousActivePlayer = NUM_PLAYERS - 1;
				}
				
				activePlayerCount++;
				
				if (activePlayerCount > NUM_PLAYERS)
				{
					this.dispatchEvent (new Event (NO_MORE_ACTIVE_PLAYERS));
					break;
				}
				
				trace ("PokerDataController::getPreviousActivePlayer player: " + previousActivePlayer + " count: " + activePlayerCount + " active: " + PokerPlayerData(_playersData[previousActivePlayer]).isActive);
			} while (!PokerPlayerData(_playersData[previousActivePlayer]).isActive);
			
			return previousActivePlayer;
		}
		
		
		private function numberActivePlayers () :Number
		{
			var activePlayerCount:Number = 0;
			for (var i:int = 0; i < NUM_PLAYERS; i++) 
			{
				if (PokerPlayerData(_playersData[i]).isActive)
				{
					activePlayerCount++;
				}
			}
			trace ("PokerDataController::numberActivePlayers " + activePlayerCount);
			return activePlayerCount;
		}
	}

}